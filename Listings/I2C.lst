C51 COMPILER V9.60.0.0   I2C                                                               09/25/2023 19:53:35 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Objects\I2C.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\I2C.c LARGE OPTIMIZE(0,SIZE) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\I2C.lst) TABS(2) OBJECT(.\Objects\I2C.obj)

line level    source

   1          #include "main.h"
   2          
   3          void I2C_Init()
   4          {
   5   1        P3M0 |= 0x0c;
   6   1        P3M1 |= 0x0c; 
   7   1      }
   8          
   9          //uint16_t AXP173_Read_ADC(uint8_t addr)
  10          //{
  11          //  
  12          //}
  13          
  14          float AXP173_Read_VBUS_Voltage()
  15          {
  16   1        float ADCLSB = 1.7 / 1000.0;
  17   1        return I2C_Read_12Bit(0x5A) * ADCLSB;
  18   1      }
  19          
  20          float AXP173_Read_VBUS_Current()
  21          {
  22   1        float ADCLSB = 0.375;
  23   1        return I2C_Read_12Bit(0x5C) * ADCLSB;
  24   1      }
  25          
  26          float AXP173_Read_APS_Voltage()
  27          {
  28   1        float ADCLSB = 1.4 / 1000.0;
  29   1        return I2C_Read_12Bit(0x7E) * ADCLSB;
  30   1      }
  31          
  32          float AXP173_Read_BAT_Voltage()
  33          {
  34   1        float ADCLSB = 1.1 / 1000.0;
  35   1        return I2C_Read_12Bit(0x78) * ADCLSB;
  36   1      }
  37          
  38          float AXP173_Read_BAT_Current()
  39          {
  40   1        float ADCLSB = 0.5;
  41   1        uint16_t CurrentIn = I2C_Read_13Bit(0x7A);
  42   1        uint16_t CurrentOut = I2C_Read_13Bit(0x7C);
  43   1        return (CurrentIn - CurrentOut) * ADCLSB;
  44   1      }
  45          
  46          float AXP173_Read_InternalTemp()
  47          {
  48   1        float ADCLSB = 0.1;
  49   1        const float OFFSET_DEG_C = -144.7;
  50   1        uint16_t ReData = I2C_Read_12Bit(0x5E);
  51   1        return OFFSET_DEG_C + ReData * ADCLSB;
  52   1      }
  53          
  54          void AXP173_Set_Voltage_DCDC2(uint16_t voltage)
C51 COMPILER V9.60.0.0   I2C                                                               09/25/2023 19:53:35 PAGE 2   

  55          {
  56   1        uint8_t dat = 0;
  57   1        if(voltage < 2275 && voltage > 700)
  58   1        {
  59   2          dat = (voltage-700)/25;
  60   2          //printf("DCDC2 %dmV 0x23=%d", voltage, dat);
  61   2          I2C_WriteByte(0x23, dat); //DC-DC2
  62   2        }
  63   1      }
  64          
  65          void AXP173_Set_Voltage_LDO4(uint16_t voltage)
  66          {
  67   1        uint8_t dat = 0;
  68   1        if(voltage < 3500 && voltage > 700)
  69   1        {
  70   2          dat = (voltage-700)/25;
  71   2          //printf("DCDC2 %dmV 0x23=%d", voltage, dat);
  72   2          I2C_WriteByte(0x27, dat); //DC-DC2
  73   2        }
  74   1      }
  75          
  76          uint16_t I2C_Read_13Bit(uint8_t addr)
  77          {
  78   1        uint16_t dat = 0;
  79   1        uint8_t dat1, dat2;
  80   1        I2C_Start();
  81   1        I2C_SendData(AXP173_ADDR);
  82   1        I2C_RecvACK();
  83   1        I2C_SendData(addr);
  84   1        I2C_RecvACK();  
  85   1        I2C_Start();
  86   1        I2C_SendData(AXP173_ADDR + 1);
  87   1        I2C_RecvACK();
  88   1        dat1 = I2C_RecvData();
  89   1        I2C_SendACK();
  90   1        dat2 = I2C_RecvData();
  91   1        I2C_SendNAK();
  92   1        I2C_Stop();
  93   1        //UartSend(dat1);
  94   1        //UartSend(dat2);
  95   1        dat = (dat1 << 5) + dat2;
  96   1        return dat;
  97   1      }
  98          
  99          uint16_t I2C_Read_12Bit(uint8_t addr)
 100          {
 101   1        uint16_t dat = 0;
 102   1        uint8_t dat1, dat2;
 103   1        I2C_Start();
 104   1        I2C_SendData(AXP173_ADDR);
 105   1        I2C_RecvACK();
 106   1        I2C_SendData(addr);
 107   1        I2C_RecvACK();  
 108   1        I2C_Start();
 109   1        I2C_SendData(AXP173_ADDR + 1);
 110   1        I2C_RecvACK();
 111   1        dat1 = I2C_RecvData();
 112   1        I2C_SendACK();
 113   1        dat2 = I2C_RecvData();
 114   1        I2C_SendNAK();
 115   1        I2C_Stop();
 116   1        //UartSend(dat1);
C51 COMPILER V9.60.0.0   I2C                                                               09/25/2023 19:53:35 PAGE 3   

 117   1        //UartSend(dat2);
 118   1        dat = (dat1 << 4) + dat2;
 119   1        return dat;
 120   1      }
 121          
 122          uint8_t I2C_ReadByte(uint8_t addr)
 123          {
 124   1        uint8_t dat = 0;
 125   1        I2C_Start();
 126   1        I2C_SendData(AXP173_ADDR);
 127   1        I2C_RecvACK();
 128   1        I2C_SendData(addr);
 129   1        I2C_RecvACK();
 130   1        
 131   1        Delay30us();
 132   1        
 133   1        I2C_Start();
 134   1        I2C_SendData(AXP173_ADDR + 1);
 135   1        I2C_RecvACK();
 136   1        dat = I2C_RecvData();
 137   1        I2C_SendNAK();
 138   1        I2C_Stop();
 139   1        return dat;
 140   1      }
 141          
 142          void I2C_WriteByte(uint8_t addr, uint8_t dat)
 143          {
 144   1        I2C_Start();
 145   1        I2C_SendData(AXP173_ADDR);
 146   1        I2C_RecvACK();
 147   1        I2C_SendData(addr);
 148   1        I2C_RecvACK();
 149   1        I2C_SendData(dat);
 150   1        I2C_RecvACK();
 151   1        I2C_Stop();
 152   1      }
 153          
 154          void I2C_Start()
 155          {
 156   1          SDA = 1;
 157   1          SCL = 1;
 158   1          Delay12us();
 159   1          SDA = 0;
 160   1          Delay12us();
 161   1          SCL = 0;
 162   1      }
 163          
 164          void I2C_SendData(uint8_t dat)
 165          {
 166   1          uint8_t i;
 167   1          for(i=0; i<8; i++)
 168   1          {
 169   2              SCL = 0;
 170   2              Delay12us();
 171   2              if(dat & 0x80) 
 172   2                  SDA = 1;
 173   2              else 
 174   2                  SDA = 0;
 175   2              dat <<= 1;
 176   2              SCL = 1;
 177   2              Delay12us();
 178   2          }
C51 COMPILER V9.60.0.0   I2C                                                               09/25/2023 19:53:35 PAGE 4   

 179   1          SCL = 0;
 180   1      }
 181          
 182          void I2C_SendACK()
 183          {
 184   1          SCL = 0;
 185   1          Delay12us();
 186   1          SDA = 0;
 187   1          SCL = 1;
 188   1          Delay12us();
 189   1          SCL = 0;
 190   1          SDA = 1;
 191   1          Delay12us();
 192   1      }
 193          
 194          void I2C_RecvACK()
 195          {
 196   1          SCL = 0;
 197   1          Delay12us();
 198   1          SDA = 1;
 199   1          SCL = 1;
 200   1          Delay12us();
 201   1          SCL = 0;
 202   1          Delay12us();
 203   1      }
 204          
 205          uint8_t I2C_RecvData()
 206          {
 207   1          uint8_t dat, i;
 208   1          for(i=0; i<8; i++)
 209   1          {
 210   2              dat <<= 1;
 211   2              SCL = 0;
 212   2              Delay12us();
 213   2              SCL = 1;
 214   2              Delay12us();
 215   2              if(SDA) dat += 1;
 216   2          }
 217   1          return dat;
 218   1      }
 219          
 220          void I2C_SendNAK()
 221          {
 222   1          SCL = 0;
 223   1          Delay12us();
 224   1          SDA = 1;
 225   1          SCL = 1;
 226   1          Delay12us();
 227   1          SCL = 0;
 228   1          Delay12us();
 229   1      } 
 230          
 231          void I2C_Stop()
 232          {
 233   1          SDA = 0;
 234   1          SCL = 1;
 235   1          Delay12us();
 236   1          SDA = 1;
 237   1          Delay12us();
 238   1      }


C51 COMPILER V9.60.0.0   I2C                                                               09/25/2023 19:53:35 PAGE 5   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1025    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     58    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
